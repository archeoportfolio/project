<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Rupe Magna</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: 3c3c3b;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Rupe Magna</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Entrare" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"209c2acf47eebf2f41026d698a51d524275f316f34e1d2cb089549218e1c070b54344514e5451957d8349aeb101bcd1fedbfe0d39ba79e929eccbbe686f85ff26e26225000daa21f783dbf8b2df1cc543d931738276e576cc51638b676bdf20a991984aeff3968dfc42ea6ff2b911dbbb7a2a26002cefb2811f5dcc2fb48f10dce6e213496bf30c5907d4662cc1e7e832ffc59f2695c7e540100b3d86f0470234c3bea5f46b10be5e26123daf02726faf09d5ec703c1b9d0e1d4e918c87c124108875b843b33ac83c13dcceee812b3c86b585accd23dc2f4a73435a011eed6a9a10232c8deac237022a6c0b771d8861fe78f9e6b3322cff555128bcbb2e5cc556433560bdf29c13a521cb2080278fc5af1cc026f367b13f53c4731d93ca95d6473520764dd9977c6894b9724e2efc0050b1fcc90b185c5d835a0cca51a6022cb4a0820d57e737315e8ab0b1d4ecb201577dd1dd5a0b7585609fe7ba8bb43e16b182ef16dbbc66e5325b6ba3113a253ba2f505c6de49e4991a73edb5fdf25af88ac5ccc8feaabbfbe20588a8a0766f7033da078b0da200cbc129dffa6de8cce6cd82f4e108907d1b4408555e2672564ecdfb2bbfd9e3fb175f8cad2bb15dc3cffa1de36901ab03ab34a67b6395612da3fe5fa923bcbe902c6dd2eddbdff0cf54330bbde202b4042d1e8a16ff93ea71b3b0ce0f151c2d1a930b9a89f1c342f19541fc41f82d6175714b56a55f4f85beaa6bd6bed93cc9aa39d2d9c8aa596bcd83ae7a4aa8a3c8c99393059f6959779c8378765ab65d8187a142958dbff11e64f687fe21ac4d7feb0429d40a18350de714f95336337918b507283ed596eb2d0781ed4d9904a9e14d417c39e731af4b0642ba94f93e07b62bcabffa3ee9fdce706358174dc02cabaa6ce60111642b76f9a82093eb1aca601eca9f568cc958e80523c7dd8a9d09594c266a15fa7f577619b38dfa1993ea615e5ccb4a8ab550cd596035c8a877ae01eb49c1fc1f34d9bb75d4ec7e96840520f458124f86bb88abd1999971ba787603953855bc968f7eb02a9c2b6dff55260fc79efb985511bc79ddd9373ed56cbbc4b44fbe374359e06d4957eee66acb65ffd4b10aad11d2777645c23a38888313ddfb0008e203d2978ad03e133a82cdce739b1fa33262d5de74668498f3a7479403fef878c13cad4a42243199bf2bb1934c4fc1cacca39b340df5b4e1f148ec1c92d8bdcbc1d64b07d8943258e2bf6103f2d36cbfe3568cd4b47d0e35192fe9fcf731802496819e0b9617499faede23aa7d00146220da7b1dd81f17cab4d1961e73b94472af6b8da7980ab853d1881bca3b25e0ffdef29db44fbdf0ba6fc606df750768341f24e36a415a018e3da29bcb7fe2687369fc22fb53ebce44182fcf26a4c3adad7719c1b2273fabc204137ab14d24b9af4ade4aee406af94d596dea9e824d9f1dd0f79733230763fdb0194737ff33830c368ee558d92df94de8d90824d5d727b27fcbb0ca3518031544f2dce55035b7da358e3b2bc19446e2f7aaec604bf3f9ae1a22210f1f445e9ab23f6748bf909145a9e84ee3fd2b901d5e2c02e62e0e8dc833ffa73d6c8c8f1f4917edd4caa6ce14bf6be54f15dc5eef45299bd17e2c052a631ed41d567ea103815613f750ab5f3a90897eb280764fccb4def64aa14383c6b028b205c103e6e16b76c50e14c773286c32005fcd719e441db69d69fcda1e83510b62914cc42b53edee5e1e59177e1dba74c779a66518ed997cb230d35ad15582eddeec5898680d9a5e7800a81593a4d26dbbbfe92674dabe26eb2335732a84834f27c30ce01c486e119654c0847bbf7393f4031e0fe4631063a47c624f340bdd25f0f100a572121dd55449a6555d98f94818a3d4767c31b6ecc40f692b6ce5f352ac19bef08b73ea3984c96866236ed5c4064e4556fbf2bf29eb7236d66bb6d58b74c766c2863fa93b15976110b50f56e91940e73e1bebd1a6f0fe9fd2f117ce3f4c4407aa00c67770f109cfef16af4116489de6d27879d66bf68d40ae389808fbbdc97e76f169781bb07d78aeeaa91de04c6b0677442a0d493594c18412fce420a2e0011a58b14ba97bb163631ee2c6a4bb33838139dc46c7736f58bf821c4a4eaf98e8cdf938c359077b16e281846678efc424ac100d68a6d5cf25ab2f9762e4cce75f4c0905b0e6a7197b0072e6a0fe491a7d0e9b7bf3b2c74b11b260caaa3b9d0de4d9a96e301511a80579617678999e2cd81c19f75e086788fea390e835c740d2365416b21307ccc0f512e835f14f7c2faca18cdcb95354cade3d1d13abb854b7bb47eddf3f9105401cfd816961d8b099c11590603d373da5f436be797a4d0bc4fbea80ff1f641710f0d87d5b09bfbcddcfc1875228aef364f2238b5fb52b8c4e92f06a6578b889fc978de28efdd3c032f8f33e3fc4e60c0d88c20d0978955701665e8b4396fe6470ec3b19114fe6160075e2e835bcd0747583749c4f2c509cd6f749ee802b377159087954939b44d7d10da318914285dd414a723c41402b3f37dc04526e7b883d329e573fc5390e9bbe31b8028c218d793f59ec445d60eb1da02cfaf9560a62b5d8d24d72e99947cd75a6bbec32c4584208c41258faa9aea2c3071282cec695e414822903185e432090575e6ced31b067cddfcce420c26a08fd85b7e532b9c76c0f679ca651a53491697f568bb6a3dc3679e56b589d518113a9691c427fc5a89284f368cf91bc2843d659c57b2fb98a69922715b18604013352a5c5c1657fb2e301ae98a573c4a316c310fb0af8075880db5103831622339624b6ff39a5c2178be2a4b85843059df3aee32f44bddac63a4a7c75679bb300221d26803f289d5b444fe4d072c3a2196cf84a3a99e05160053229ee7e03fedd0499815185c39e967cf10dd22463843c0a4e5dd426bb37d964dcb7c4752d2dd7a7233780434b5a6a4ed8939a4a7ffe038aa77c393ae863be05141a71aca88abe9acf9083a0b19934cd434033a1cd1c2ffa883fcaca05b58a95b9cff5febac8e369a28d9b47e9440f5a9ce249d4c0e86e70a7ae8bb28ab7b438309969afc07a8d62e01bc27f8763d8bd0a44ed039f29fcf55c1ffc19910468634bc44641ca6874eea2cf0badfb684d92b2998a151742b7b6cebb2cac306f74b0e8bfea9eb2a142d9fa830171687de79a7e3035043702421517cef9802966571c588803d1812e32925a94510b6898aaaa12ecf3bd9d0dca93ae93fb3ceb54c9f3a9db569e85fb44e2e05c823c703528297f2a54564233372ce3d9f24c0a665a63e64dbfc0d86f844ecc99f1f6383e70175a7d7adc4937c01bb784029ce854814e314bead04b62054d8c24f5e4077336cb5baf5a8c9e9e2bbdf2c99763ceb4fd573beba85369cb7f340442aa97f69cb99a1ad8fbbdd821bf522b4030b96fc2319d631773d0af304e4149a6ee87df722df1700c93b74e24628fb2a739657aa9a3488cdc5ce843a8efe92bb316ac42febc558f0947270f84ffc2bca565d7553cf90f035c0a0d2b7b5d135f63b12b32ebe5ade4f5ccc3bebf7e54368b232877a6a920923a8fe86cf6cdc2e72593c33e636c00a9881b02a79fbeb79e61a476a18a818f7cca6888f808b3a66e6b5dece93921083eeaf63a065b5f6592397f641d4961a29aa3dc09350041f850a40f4dde6a3212638e98cd6a7082fe77d1bca4ec5f76d18099e62d80a2fef8db2b9bf2e7ca7cca04623941fdef1514663b55b29138ec5f9a8177024b3c010810bfd138c7762f53d0d28a29f12edddf4733845d1db9456b9e9336009e0be2fa5eda95ce045405128f4e4b7eb54a8e2225a76ffdb91feade79ba4798d457d52fda345214ebe7c48f6345d4b063edc103222fcf13a9b7d0c984c69ea2bcd4da8db4dececeaf77a0b4c66d4139fe4ed93c6dc0431abcd4d57b2e792a0378d473eef60374094f9a1f42dd0dfa22864f4cfd6f4a9d6621f29ed8e17b019165048f5ea2e903701976ab38c66913182c3fff99b4452ccfdba84f0ad32096027b2d9146e8f4a8da190af9e13f011c3bbece9054fcd0099f657f54f1eb0365a61f26d8bc595cccfc33d83f370392db7b2c8cc30553a38d2ca498b562a0f0126edf33f779fdc6f7156c5ae46f53d42ed22ca8613d7900021286baf59e5b83f53561626f7af044ec60166ffd34b03afb05974eea150bdfe314146cde471de00056b36bd791c5e1840fa0fb59bf9c3eabe2696abb8f4f11bc7b2e1dabf9b68fe6604168e5fc0fb5d739aa46fded0ce150999adbb2a2c27c525151c09668891cdbf981af5d044abd75389df5cec4efe5a32fdeb34450e458c3e7f392722a09845d25207e9bc8b96fb36ecb12945a80e24c25e1a9e96d646a7067958032b3e5b399309c76e9e6bfcc26b2c3dbb0c2d5d03324c75e87f20ce83f172f667df3f26639e718bfa66cc5a064fe8b9dcbfd2712c92d2f269a010a3b5c699a51c583197659fba9fb965506b71f924916f8ce9e95950ee2e8ffc5a772fa2a0dda85d4b516c642fd6be36850aadbcf4894e0ed2a759cf2b3bc9355855e84c5d5f42371074e375d392a659e53f3c10d358afbb970cf2f6392aad3b97c6419e8238e9ca3e7cc0247b3145071de421a987f69338350946802f6bf1d2f02a1138ade73479636fe49d929468e9e523ed3d73badc70d46ebe0f16ab7743b6806ae114a978eebd42b0b557419720b14bc59a4c65a25792d5cfad437a9ee80d229c51e10aeee14650e9d89e0dd806fbb96ff8fc50bd2d1f09551598a2a2602a7502aea410224dc53a510bb255c0fc8105ab3a48363335f51fa8e4a84fcd574bb64cc2ecdf793dbf33e97613ea2fe7c08043e6bad6c4828ca8e5d6d6a46676b866b2aab4c779492bf5ae311b5a4ffad653f8fa5762327a3951ce462b69caab3c373a3591380c31df98a0d1138159c93dff51bf0f6b38e0692afd8023207f107665cec85179b24e3a5e11efd53114c94bf9aa16b86a9f724b3f8c8b11d7461e65cc9a03793d3ad5a4cd5aa04734189bdbb61ac5b0f449f965bff785695b72e08fbed786f7fe480217d08aa9b3fd74f8a38de4c042a0a5af496c40567baf3763b34de22d91136f30b0efb72c2b1b62f501a9ebcf7c691fa895e9b2f0ff7c7ec755d73d3e9617ee66c5c759e4d955251f157f0b8a369b79f9aee90c2763f4e8e031bdaacf044eed2d275318699330c8b9711ca82ce66700fc951bb94700a6ba52fc83739a5635f45214dfe1049f48244a9d83785a4fe6b3c9245008d54d9cb8bdfbf8293ef5d2e874136e99aa50598199dbe0d5fa36745d9dbf094fdabc0d608e8b22e7479b58fe04bda8d9bcead1479666bad16b6cb2839a4d3bd15428722204250b62882a8bf369bd9a8edfe1ceff4d1a453f6b92bfdde8a6bcc37a254a02d151f098b47c52f88e9a186a6a1f2d60cb05915ebc6d0d3282343a3311b849b08792865c210f8e7e33bf8b2ca7f10ae4c5d4d61620fd2097e7af070425a32e21c3155763653fd2500f34ab5ff1d98f38d8937cff9f06b6c5c9ad97ce0facd4340c2aa76c1d4f900db55df72ac4d99ec081dde7af4e7c58eab64f4ec88d158cb911ac3e59729416ddbc0060fcbd52e8930dd0615fff7bdfdfd78032f9c10806cf221eb3e660fc99b473088af2a54ea2930e77777826f92573ce4d68250098405911de93d137aaad187a577784b19734624134da271935318966ec55815256f61d5dc3cdc00aea253a57c94ade429ca890a867f674ae9d227cb651783b83eab7c0a46c1df3b0c8ac926e75e5d3b8358ed16d41b4ad8fd59df416875f9e57502a24a00517bb56f921676afb8bf8d17b66e42bf7b4565691748fa2a26e4db992e988f437f5c2c4899acf2afaf2f91dec60a8810c571e98aabbdb1428b4580a4ccc3228bac0292efa1bbf24562e77aa30f5696883e8b6c40afafd10d51ad15f5b9cedb04eaa2433c1a92a642e2647fa2f0699f724370bcb92087b387cf9fb5a2a000dd0bbfe6ec66f5c343e349ff336229ba4ae30a356ef57254b6e81e6aadca9a5a5f5db696d2285b5b8b5ebc815a24a658b7dd1a3f2c6c97ef533cd0a6b7197cd2ce516033f3f968e7422a7d0b3e89482b619b54d10e75893e9dc3f044e19707659179e39e0be873383ac6c3ec677bde364b27d244e5d936558c94174a6d320cccd8187a81ccd5d480d6057db1065256059ef5c4902a1a94c1ccf7d5c7440cf81437621c825ec5d22388428ac24556775e77d9aab96aa9bf27a55397fdbb08e81f87282dddd5609a959efa1f25cc9f23f9ce551ba7b405b35627e5316e18aed2385b564a2f8ee5fea223f526749dbc8645de2c1de34d6c94b2511cc957a3070d70395e7ff1b21993a9e21e56be7f6b2bf104c8849d062b955227701a817417d354b1bd9da2c90517a99b16340a7281568b97701f9588ed979b687256fd3010876ac71660a46f3c073b2f112914894b6922353d8616004bf0dcb082bc615faa4189266285cf1ec05197daa93ab2871e0a7ce1980baf36b49927cbf3a59323129016036e5241ccc597481973ddcc9603a03362a68a1bf12041900d55babebf1c9ab45e28280aa628c91b6f8a82229a556efd75c8bc915cdcb07795a17e01994daadbad218c0041730bfea592a3d1d996726b004d422d00f2980af2402f6dc70c2fd0812c0f76c58e56abd35424afd2bee5fbd329b076d162a601f72ea9eed79ca356d80af18f94a5b73186435180c2cf96cc12860fcc33c337705e68c9fa87aa47d56d09c0a6196e7271ec15c6268cb46e0dd0266b341441feaab619a8468b3fcb1290a6c374e1b8f04cb6b9fb357c5ed88d9a35e6f0af12bb8716d88fe365e0d02b1b94f4a1836c3cf7a7010cccc32377503ae110c886fde26531bfe0a1c7641c55bd9874ca0f83cbfb50e6658b1443900207853d1c2f3b5782c8d3980045a0c32059e580e9095f3d568b0171bf9c2d8018630579384030c53fddcc816d7c7433ceacf3ca865a155","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"25ba8e62104b97c38800d176cd6b4ca1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
